#include    <iostream>
#include    <string>
#include    <algorithm>
#include    <vector>
#include    <iterator>

static int col_counter; // counts how many cities we have
void column_counter(std::string given_line);
int **existing_road_matrix_maker(std::string line); // matrix making function for the existing roads
int **building_road_matrix_maker(std::string line); // matrix making function for the cost to build roads
int **destroy_road_matrix_maker(std::string line); // matrix making function for the cost to destroy roads
void printarray(int **arr); // prints the integer matrix

bool onepath(int **existing_array); // this function checks if only one path exists between every pair of cities
bool min_test_function(std::pair<int, std::pair<int,int>> a, std::pair<int, std::pair<int,int>> b){return a.first < b.first;} 
bool max_test_function(std::pair<int, std::pair<int,int>> a, std::pair<int, std::pair<int,int>> b){return a.first > b.first;} 
// this class creates a graph that will hold the parents and the weight of each node
class Graph
{
    public:
        Graph(int n)
        {
        for (int i=0; i<n; i++) // each int represents cities, A=0, B=1 ... matches the IDs as generated by the for-loops (also 0-based index) in the main
            this->create(i);
        }
  
        
        int find(int x) {
            if (parent[x] == x)
            return x;
            return find(parent[x]); 
        } 
        void create(int x) {
            std::vector<int>::iterator loc = parent.begin() + x;
            parent.insert(loc,x);

            loc = weight.begin() + x;
            weight.insert(loc,1); // for initialisation
        }
        void n_union(int a, int b) { // a and b are vals, not node IDs. immaterial to this assignment however
            a = find(a); b = find(b);

            if (a == b) // no actions to unify node with itself
            return;

            // tree with smaller height becomes a subtree of the larger tree
            int cmp = weight[a] - weight[b]; // comparison optimisation
            if (cmp < 0) // b is bigger
            parent[a] = b;
            else if (cmp > 0) // a is bigger
            parent[b] = a;
            else { // trees are same weight, so make A root of B and increment weight of A (or, technically, vice-versa)
            parent[b] = a;
            weight[a]++;
            }

        } 
        private:
        std::vector<int> parent;
        std::vector<int> weight;
};

int min_cost(int **existing_array, int **building_array, int **destroy_array, Graph given_graph){ // this function gives the min cost
		
        std::vector<std::pair<int,std::pair<int,int>>> build_cost_vector, destroy_cost_vector; int minimum = 0;
		// iterating over all roads, and if they exist we add the cost to destroy to the destroy cost vector (alongside the nodes), otherwise we add the cost to build (alongside the nodes)

		for(int first_city = 0; first_city < col_counter; first_city++)
		{
			for(int second_city = 0; second_city < first_city; second_city++)
			{
				if(existing_array[first_city][second_city] == 1){ // if a road does exist
					std::pair<int,std::pair<int,int>> edge_info (destroy_array[first_city][second_city], std::make_pair(first_city, second_city));
					destroy_cost_vector.push_back(edge_info);

				} else if (existing_array[first_city][second_city] == 0){ // if a road does not exist
					std::pair<int, std::pair<int,int>> edge_info (building_array[first_city][second_city], std::make_pair(first_city, second_city));
					build_cost_vector.push_back(edge_info);
				}
			}
		}
		
		// sorting each vector now to find the min
		std::sort(build_cost_vector.begin(), build_cost_vector.end(), min_test_function);
		std::sort(destroy_cost_vector.begin(), destroy_cost_vector.end(), max_test_function);

		// for(auto a : build_cost_vector){
		// 	std::cout << a.first << " " << a.second.first << " " <<a.second.second <<"\n";
		// }
		// iterating over the nodes and if they exist in the graph we add their build cost to the min cost, if they don't we just add them to the graph and move on
		for(int i = 0; i < static_cast<int>(destroy_cost_vector.size()); i++)
		{
			// std::cout << destroy_cost_vector.at(i).first << "\n";
			std::pair<int, int> current_nodes = destroy_cost_vector.at(i).second;
			// if the two nodes have the same parent
			if(given_graph.find(destroy_cost_vector.at(i).second.first) == given_graph.find(destroy_cost_vector.at(i).second.second)){
				minimum = minimum + destroy_cost_vector.at(i).first;
				// std::cout << build_cost_vector.at(i).first << "\n";
			} else {
				given_graph.n_union(current_nodes.first, current_nodes.second); // if they don't we add them to the graph
			}
		}

		for(int i = 0; i < static_cast<int>(build_cost_vector.size()); i++)
		{

			if(given_graph.find(build_cost_vector.at(i).second.first) != given_graph.find(build_cost_vector.at(i).second.second)){
				minimum = minimum + build_cost_vector.at(i).first;
				given_graph.n_union(build_cost_vector.at(i).second.first, build_cost_vector.at(i).second.second); // if they don't we add them to the graph
			}
			
		}

		// int nibbles = findParent(build_cost_vector.at(2).second.first);

		return minimum;
	}

/*
Constraints for the assignment:
We need, after reconstruction, exactly one path between each city pairs
-> can not have multiple paths between cities (can we just create a ring route?)
--> Ring route will not be an optimal solution
We need to find the minimal cost for reconstruction (minimal cost to ensure that there is exactly one path between city pairs)
-> But a
*/

int main()
{
	col_counter = 0;
	std::string line;
	std::getline(std::cin, line); // saving all information into line which we can then separate

	column_counter(line); // finding out how big our matrices need to be
	int **existing_road_matrix = existing_road_matrix_maker(line);
	int **building_road_matrix = building_road_matrix_maker(line);
	int **destroy_road_matrix = destroy_road_matrix_maker(line);


	if(col_counter == 1){std::cout << "0\n";} //  we know that if there is only one element that we do not need any roads and hence there will not be any cost associated
	else {
		if(onepath(existing_road_matrix) != true){
			Graph thisgraph(col_counter);
			std::cout << min_cost(existing_road_matrix, building_road_matrix, destroy_road_matrix, thisgraph) <<"\n";}
		else {
			std::cout << "0\n";
		}
	}



	delete [] existing_road_matrix;
	delete [] building_road_matrix;
	delete [] destroy_road_matrix;

}
// function to count how many columns we are going to need (and then also the row amount because it is a n*n matrix)
void column_counter(std::string given_line)
{
	int counter = 0;
	for(int i = 0; i < given_line.size(); i++)
	{
		if(given_line.at(i) == ' ') // breaking the loop if we hit a space (this signifies the end of the cols)
		{
			counter++;
			break;
		} 
		else if(given_line.at(i) == ',')
		{
			counter++;
		}
	}
	col_counter = counter; // setting the col_counter to be the amount of columns we need
	return;
}



// for this assignment we need an existing road  matrix maker, a builder matrix maker and a destroyer matrix maker

// the function that creates the existing road matrix
int **existing_road_matrix_maker(std::string line)
{
	// we take the first col_counter partitions
	// allocating the matrix
	int n = col_counter;
	int **existing_road_matrix = new int*[col_counter]; // n * n matrix
	for(int i = 0; i < col_counter; i++) 
	{
		existing_road_matrix[i] = new int[col_counter];
	}

	// transferring the stuffs into the matrix
	int row_index = 0; int col_index = 0;
	for(int i = 0; i < line.size() && i < (n*n + n); i++){ // iterating over the string until we hit n*n + n
		// std::cout << line.at(i) << " ";
		// if(line.at(i)==','){col_index++;}
		if(line.at(i) == ','){row_index++; col_index=0;}
		else {existing_road_matrix[row_index][col_index] = line.at(i)-48; col_index++;}
	}

	return existing_road_matrix;
}

// function that creates the matrix for building cost
int **building_road_matrix_maker(std::string line)
{
	int n = col_counter;
	int **building_road_matrix = new int*[col_counter]; // n * n matrix
	for(int i = 0; i < col_counter; i++) 
	{
		building_road_matrix[i] = new int[col_counter];
	}

	// transferring the stuffs into the matrix
	int row_index = 0; int col_index = 0;
	for(int i = (n*n+n); i < line.size() && i < 2*(n*n + n); i++){ // iterating over the string until we hit 2(n*n + n)+1
		
		if(line.at(i) == ','){row_index++; col_index = 0;}
		else {
			if(line.at(i) >= 'a' && line.at(i) <= 'z'){
				building_road_matrix[row_index][col_index] = line.at(i)-'a' + 26; col_index++;
			} else {
				building_road_matrix[row_index][col_index] = line.at(i)-'A'; col_index++;
			}
		}
	}

	return building_road_matrix;
}

int **destroy_road_matrix_maker(std::string line)
{
	int n = col_counter;
	int **destroy_road_matrix = new int*[col_counter]; // n * n matrix
	for(int i = 0; i < col_counter; i++) 
	{
		destroy_road_matrix[i] = new int[col_counter];
	}

	// transferring the stuffs into the matrix
	int row_index = 0; int col_index = 0;
	for(int i = 2*(n*n+n); i < line.size(); i++){ // iterating over the string until we hit the end (starting from 2*(n*n+n)+1)
		if(line.at(i) == ','){row_index++; col_index = 0;}
		else {
			if(line.at(i) >= 'a' && line.at(i) <= 'z'){
				destroy_road_matrix[row_index][col_index] = line.at(i)-'a' + 26; col_index++;
			} else {
				destroy_road_matrix[row_index][col_index] = line.at(i)-'A'; col_index++;
			}
		}
	}

	return destroy_road_matrix;
}

void printarray(int **arr){
	for(int i = 0; i < col_counter; i++){
		for(int j = 0; j < col_counter; j++){
			std::cout << arr[i][j] << " ";
		} std::cout << std::endl;
	}
}



bool onepath(int **existing_array)
{
	int links = 0;
	for(int i = 0; i < col_counter; i++) // iterating across each row
	{
		for(int j = 0; j < col_counter; j++) // iterating across each column for each row
		{
			if(existing_array[i][j] == 1)
			{
				links ++;
			}
		}
	}
	if (links == col_counter){return true;} // if we have n amount of links it means there is only 1 path (but we can double check this later)
	return false;
}
